<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0044)http://introcs.cs.princeton.edu/java/42sort/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<link rel="icon" href="http://introcs.cs.princeton.edu/favicon.ico" type="image/x-icon">
<link rel="shortcut icon" href="http://introcs.cs.princeton.edu/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="./Sorting and Searching_files/introcs.css" type="text/css">
<meta name="google-site-verification" content="nYspbl5bNBQrNZKguiAAFTMVM7sq2P1WQYc8Oi6Okl0">
<meta name="msvalidate.01" content="D4B7F6DF793EFF34DE96F611C2A367A5">
<!-- IE HACKS -->
<!--[if IE]>
<style type="text/css" media="screen">
 #menu ul li {float: left; width: 100%;}
</style>
<![endif]-->
<!--[if lt IE 7]>
<style type="text/css" media="screen">
body {
behavior: url(/csshover.htc);
} 
#menu ul li {float: left; width: 100%;}
#menu ul li a {height: 1%;} 

#menu a, #menu h2 {
font: bold 0.9em/1.5em arial, helvetica, sans-serif;
} 

</style>
<![endif]-->


<title>
Sorting and Searching</title>
<script type="text/javascript" async="" src="./Sorting and Searching_files/cse.js"></script><script type="text/javascript" src="./Sorting and Searching_files/swfobject.js"></script>


<meta name="AUTHOR" content="Robert Sedgewick and Kevin Wayne">
<meta name="KEYWORDS" content="Sorting and Searching,Java,Programming,interdisciplinary,Computer science,cs,intro,introduction,sedgewick,wayne">
<meta name="DESCRIPTION" content="This textbook provides an interdisciplinary approach to the CS 1 curriculum. We teach the classic elements of programming, using an " objects-in-the-middle"="" approach="" that="" emphasizes="" data="" abstraction.="" a="" key="" feature="" of="" the="" book="" is="" manner="" in="" which="" we="" motivate="" each="" programming="" concept="" by="" examining="" its="" impact="" on="" specific="" applications,="" taken="" from="" science,="" engineering,="" and="" commerce."="">
<meta name="TITLE" content="Sorting and Searching. Introduction to Programming in Java by Sedgewick and Wayne">
<meta name="ROBOTS" content="INDEX,FOLLOW">
<meta name="verify-v1" content="D4o9ikkHbNKapHncCP8ZmiD9Z2DBbrJyaSV0lyce+3w=">


<script src="./Sorting and Searching_files/jsapi" type="text/javascript"></script><link type="text/css" href="./Sorting and Searching_files/default+en.css" rel="stylesheet"><link type="text/css" href="./Sorting and Searching_files/default.css" rel="stylesheet"><script type="text/javascript" src="./Sorting and Searching_files/default+en.I.js"></script><script type="text/javascript" src="./Sorting and Searching_files/search.I.js"></script><style type="text/css">
.gsc-control-cse {
font-family: Arial, sans-serif;
border-color: #FFFFFF;
background-color: #FFFFFF;
}
.gsc-control-cse .gsc-table-result {
font-family: Arial, sans-serif;
}
input.gsc-input {
border-color: #D9D9D9;
}
input.gsc-search-button {
border-color: #666666;
background-color: #CECECE;
}
.gsc-tabHeader.gsc-tabhInactive {
border-color: #E9E9E9;
background-color: #E9E9E9;
}
.gsc-tabHeader.gsc-tabhActive {
border-top-color: #FF9900;
border-left-color: #E9E9E9;
border-right-color: #E9E9E9;
background-color: #FFFFFF;
}
.gsc-tabsArea {
border-color: #E9E9E9;
}
.gsc-webResult.gsc-result,
.gsc-results .gsc-imageResult {
border-color: #FFFFFF;
background-color: #FFFFFF;
}
.gsc-webResult.gsc-result:hover,
.gsc-imageResult:hover {
border-color: #FFFFFF;
background-color: #FFFFFF;
}
.gsc-webResult.gsc-result.gsc-promotion:hover {
border-color: #FFFFFF;
background-color: #FFFFFF;
}
.gs-webResult.gs-result a.gs-title:link,
.gs-webResult.gs-result a.gs-title:link b,
.gs-imageResult a.gs-title:link,
.gs-imageResult a.gs-title:link b {
color: #0000CC;
}
.gs-webResult.gs-result a.gs-title:visited,
.gs-webResult.gs-result a.gs-title:visited b,
.gs-imageResult a.gs-title:visited,
.gs-imageResult a.gs-title:visited b {
color: #0000CC;
}
.gs-webResult.gs-result a.gs-title:hover,
.gs-webResult.gs-result a.gs-title:hover b,
.gs-imageResult a.gs-title:hover,
.gs-imageResult a.gs-title:hover b {
color: #0000CC;
}
.gs-webResult.gs-result a.gs-title:active,
.gs-webResult.gs-result a.gs-title:active b,
.gs-imageResult a.gs-title:active,
.gs-imageResult a.gs-title:active b {
color: #0000CC;
}
.gsc-cursor-page {
color: #0000CC;
}
a.gsc-trailing-more-results:link {
color: #0000CC;
}
.gs-webResult .gs-snippet,
.gs-imageResult .gs-snippet,
.gs-fileFormatType {
color: #000000;
}
.gs-webResult div.gs-visibleUrl,
.gs-imageResult div.gs-visibleUrl {
color: #008000;
}
.gs-webResult div.gs-visibleUrl-short {
color: #008000;
}
.gs-webResult div.gs-visibleUrl-short {
display: none;
}
.gs-webResult div.gs-visibleUrl-long {
display: block;
}
.gs-promotion div.gs-visibleUrl-short {
display: none;
}
.gs-promotion div.gs-visibleUrl-long {
display: block;
}
.gsc-cursor-box {
border-color: #FFFFFF;
}
.gsc-results .gsc-cursor-box .gsc-cursor-page {
border-color: #E9E9E9;
background-color: #FFFFFF;
color: #0000CC;
}
.gsc-results .gsc-cursor-box .gsc-cursor-current-page {
border-color: #FF9900;
background-color: #FFFFFF;
color: #0000CC;
}
.gsc-webResult.gsc-result.gsc-promotion {
border-color: #336699;
background-color: #FFFFFF;
}
.gsc-completion-title {
color: #0000CC;
}
.gsc-completion-snippet {
color: #000000;
}
.gs-promotion a.gs-title:link,
.gs-promotion a.gs-title:link *,
.gs-promotion .gs-snippet a:link {
color: #0000CC;
}
.gs-promotion a.gs-title:visited,
.gs-promotion a.gs-title:visited *,
.gs-promotion .gs-snippet a:visited {
color: #0000CC;
}
.gs-promotion a.gs-title:hover,
.gs-promotion a.gs-title:hover *,
.gs-promotion .gs-snippet a:hover {
color: #0000CC;
}
.gs-promotion a.gs-title:active,
.gs-promotion a.gs-title:active *,
.gs-promotion .gs-snippet a:active {
color: #0000CC;
}
.gs-promotion .gs-snippet,
.gs-promotion .gs-title .gs-promotion-title-right,
.gs-promotion .gs-title .gs-promotion-title-right * {
color: #000000;
}
.gs-promotion .gs-visibleUrl,
.gs-promotion .gs-visibleUrl-short {
color: #008000;
}
.gsc-input input.gsc-input {
background: none repeat scroll 0% 0% white !important;
}
</style><style type="text/css">.gssb_c{border:0;position:absolute;z-index:989}.gssb_e{border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-webkit-box-shadow:0 2px 4px rgba(0,0,0,0.2);cursor:default}.gssb_f{visibility:hidden;white-space:nowrap}.gssb_k{border:0;display:block;position:absolute;top:0;z-index:988}.gsdd_a{border:none!important}.gsib_a{width:100%;padding:4px 6px 0}.gsib_a,.gsib_b{vertical-align:top}.gssb_a{padding:0 7px}.gssb_a,.gssb_a td{white-space:nowrap;overflow:hidden;line-height:22px}#gssb_b{font-size:11px;color:#36c;text-decoration:none}#gssb_b:hover{font-size:11px;color:#36c;text-decoration:underline}.gssb_g{text-align:center;padding:8px 0 7px;position:relative}.gssb_h{font-size:15px;height:28px;margin:0.2em;-webkit-appearance:button}.gssb_i{background:#eee}.gss_ifl{visibility:hidden;padding-left:5px}.gssb_i .gss_ifl{visibility:visible}a.gssb_j{font-size:13px;color:#36c;text-decoration:none;line-height:100%}a.gssb_j:hover{text-decoration:underline}.gssb_l{height:1px;background-color:#e5e5e5}.gssb_m{color:#000;background:#fff}.gscsep_a{display:none}.gsq_a{padding:0}.gsfe_a{border:1px solid #b9b9b9;border-top-color:#a0a0a0;box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.1);}.gsfe_b{border:1px solid #4d90fe;outline:none;box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);-moz-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);-webkit-box-shadow:inset 0px 1px 2px rgba(0,0,0,0.3);}.gscb_a{display:inline-block;font:27px/13px arial,sans-serif}.gsst_a .gscb_a{color:#a1b9ed;cursor:pointer}.gsst_a:hover .gscb_a,.gsst_a:focus .gscb_a{color:#36c}.gsst_a{display:inline-block}.gsst_a{cursor:pointer;padding:0 4px}.gsst_a:hover{text-decoration:none!important}.gsst_b{font-size:16px;padding:0 2px;user-select:none;-webkit-user-select:none;white-space:nowrap}.gsst_e{opacity:0.55;}.gsst_a:hover .gsst_e,.gsst_a:focus .gsst_e{opacity:0.72;}.gsst_a:active .gsst_e{opacity:1;}.gsst_f{background:white;text-align:left}.gsst_g{background-color:white;border:1px solid #ccc;border-top-color:#d9d9d9;box-shadow:0 2px 4px rgba(0,0,0,0.2);-webkit-box-shadow:0 2px 4px rgba(0,0,0,0.2);margin:-1px -3px;padding:0 6px}.gsst_h{background-color:white;height:1px;margin-bottom:-1px;position:relative;top:-1px}.gssb_a{padding:0 7px}.gssb_e{border:0}.gssb_l{margin:5px 0}.gssb_c .gsc-completion-container{position:static}.gssb_c{z-index:5000}.gsc-completion-container table{background:transparent;font-size:inherit;font-family:inherit}.gssb_c > tbody > tr,.gssb_c > tbody > tr > td,.gssb_d,.gssb_d > tbody > tr,.gssb_d > tbody > tr > td,.gssb_e,.gssb_e > tbody > tr,.gssb_e > tbody > tr > td{padding:0;margin:0;border:0}.gssb_a table,.gssb_a table tr,.gssb_a table tr td{padding:0;margin:0;border:0}</style></head>





<body>

<div id="menu">
   <div align="center">
<a class="picture" href="http://introcs.cs.princeton.edu/home">
<img src="./Sorting and Searching_files/cover.jpg" width="188" height="233" border="0" alt="Introduction to Programming in Java">
</a>
</div>






<ul>
  <li><a class="title" href="http://introcs.cs.princeton.edu/java/home">Intro to Programming</a>
    <ul>

      <li> <a href="http://introcs.cs.princeton.edu/java/10elements">1.&nbsp;&nbsp;Elements of Programming</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/11hello">1.1&nbsp;&nbsp;Your First Program</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/12types">1.2&nbsp;&nbsp;Built-in Types of Data</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/13flow">1.3&nbsp;&nbsp;Conditionals and Loops</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/14array">1.4&nbsp;&nbsp;Arrays</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/15inout">1.5&nbsp;&nbsp;Input and Output</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/16pagerank">1.6&nbsp;&nbsp;Case Study: PageRank</a>
        </li></ul>

      </li><li> <a href="http://introcs.cs.princeton.edu/java/20functions">2.&nbsp;&nbsp;Functions</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/21function">2.1&nbsp;&nbsp;Static Methods</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/22library">2.2&nbsp;&nbsp;Libraries and Clients</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/23recursion">2.3&nbsp;&nbsp;Recursion</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/24percolation">2.4&nbsp;&nbsp;Case Study: Percolation</a>
        </li></ul>

      </li><li> <a href="http://introcs.cs.princeton.edu/java/30oop">3.&nbsp;&nbsp;OOP</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/31datatype">3.1&nbsp;&nbsp;Data Types</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/32class">3.2&nbsp;&nbsp;Creating Data Types</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/33design">3.3&nbsp;&nbsp;Designing Data Types</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/34nbody">3.4&nbsp;&nbsp;Case Study: N-Body</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/35purple">3.5&nbsp;&nbsp;Purple America</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/36inheritance">3.6&nbsp;&nbsp;Inheritance</a>
        </li></ul>

      </li><li> <a href="http://introcs.cs.princeton.edu/java/40algorithms">4.&nbsp;&nbsp;Data Structures</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/41analysis">4.1&nbsp;&nbsp;Performance</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/42sort">4.2&nbsp;&nbsp;Sorting and Searching</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/43stack">4.3&nbsp;&nbsp;Stacks and Queues</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/44st">4.4&nbsp;&nbsp;Symbol Tables</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/45graph">4.5&nbsp;&nbsp;Case Study: Small World</a>
        </li></ul>
    </li></ul>
</li></ul>





<ul>
  <li><a class="title" href="http://introcs.cs.princeton.edu/java/cs">Intro to CS</a>
    <ul>

      <li> <a href="http://introcs.cs.princeton.edu/java/00prologue">0.&nbsp;&nbsp;Prologue</a>
        <ul>
        </ul>

      </li><li> <a href="http://introcs.cs.princeton.edu/java/50machine">5.&nbsp;&nbsp;A Computing Machine</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/51data">5.1&nbsp;&nbsp;Data Representations</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/52toy">5.2&nbsp;&nbsp;TOY Machine</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/53isa">5.3&nbsp;&nbsp;TOY Instruction Set</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/54programming">5.4&nbsp;&nbsp;TOY Programming</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/55simulator">5.5&nbsp;&nbsp;TOY Simulator</a>
        </li></ul>

      </li><li> <a href="http://introcs.cs.princeton.edu/java/60circuits">6.&nbsp;&nbsp;Building a Computer</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/61combinational">6.1&nbsp;&nbsp;Combinational Circuits</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/62sequential">6.2&nbsp;&nbsp;Sequential Circuits</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/63architecture">6.3&nbsp;&nbsp;Building a TOY</a>
        </li></ul>

      </li><li> <a href="http://introcs.cs.princeton.edu/java/70theory">7.&nbsp;&nbsp;Theory of Computation</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/71language">7.1&nbsp;&nbsp;Formal Languages</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/72regular">7.2&nbsp;&nbsp;Regular Expressions</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/73dfa">7.3&nbsp;&nbsp;Finite State Automata</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/74turing">7.4&nbsp;&nbsp;Turing Machines</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/75universality">7.5&nbsp;&nbsp;Universality</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/76computability">7.6&nbsp;&nbsp;Computability</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/77intractability">7.7&nbsp;&nbsp;Intractability</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/78crypto">7.8&nbsp;&nbsp;Cryptography</a>
        </li></ul>

      </li><li> <a href="http://introcs.cs.princeton.edu/java/80systems">8.&nbsp;&nbsp;Systems</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/81library">8.1&nbsp;&nbsp;Library Programming</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/82compiler">8.2&nbsp;&nbsp;Compilers</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/83os">8.3&nbsp;&nbsp;Operating Systems</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/84network">8.4&nbsp;&nbsp;Networking</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/85application">8.5&nbsp;&nbsp;Applications Systems</a>
        </li></ul>

      </li><li> <a href="http://introcs.cs.princeton.edu/java/90scientific">9.&nbsp;&nbsp;Scientific Computation</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/91float">9.1&nbsp;&nbsp;Floating Point</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/92symbolic">9.2&nbsp;&nbsp;Symbolic Methods</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/93integration">9.3&nbsp;&nbsp;Numerical Integration</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/94diffeq">9.4&nbsp;&nbsp;Differential Equations</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/95linear">9.5&nbsp;&nbsp;Linear Algebra</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/96optimization">9.6&nbsp;&nbsp;Optimization</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/97data">9.7&nbsp;&nbsp;Data Analysis</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/98simulation">9.8&nbsp;&nbsp;Simulation</a>
        </li></ul>
    </li></ul>
</li></ul>







<ul>

  <li><a class="title" href="http://algs4.cs.princeton.edu/">Algorithms, 4th Edition</a>
    <ul>
<a class="booksite" href="http://algs4.cs.princeton.edu/">
<img src="./Sorting and Searching_files/cover.png" width="50%" border="0" alt="Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne"></a>
   </ul>

  </li><li><a class="title" href="http://introcs.cs.princeton.edu/home">Web Resources</a>
    <ul>

      <li> <a href="http://introcs.cs.princeton.edu/java/faq">FAQ</a>
      </li><li> <a href="http://introcs.cs.princeton.edu/java/data">Data</a>
      </li><li> <a href="http://introcs.cs.princeton.edu/java/code">Code</a>
      </li><li> <a href="http://introcs.cs.princeton.edu/java/errata">Errata</a>
      </li><li> <a href="http://introcs.cs.princeton.edu/java/11appendix">Appendices</a>
        <ul>
          <li> <a href="http://introcs.cs.princeton.edu/java/11precedence">A. &nbsp; Operator Precedence</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/11style">B. &nbsp; Writing Clear Code</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/11gaussian">C. &nbsp; Gaussian Distribution</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/11cheatsheet">D. &nbsp; Java Cheatsheet</a>
          </li><li> <a href="http://introcs.cs.princeton.edu/java/11matlab">E. &nbsp; Matlab</a>
        </li></ul>
      </li><li> <a href="http://introcs.cs.princeton.edu/java/lectures">Lecture Slides</a>
      </li><li> <a href="http://introcs.cs.princeton.edu/java/assignments">Programming Assignments</a>
   </li></ul>


</li></ul>

<p><br>


<script>
  (function() {
    var cx = '005649317310637734940:_d158dlngnk';
    var gcse = document.createElement('script');
    gcse.type = 'text/javascript';
    gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.com/cse/cse.js?cx=' + cx;
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(gcse, s);
  })();
</script>
<div id="___gcse_0"><div class="gsc-control-searchbox-only gsc-control-searchbox-only-en" dir="ltr"><form class="gsc-search-box" accept-charset="utf-8"><table cellspacing="0" cellpadding="0" class="gsc-search-box"><tbody><tr><td class="gsc-input"><input autocomplete="off" type="text" size="10" class=" gsc-input" name="search" title="search" id="gsc-i-id1" dir="ltr" spellcheck="false" style="outline: none;"></td><td class="gsc-search-button"><input type="button" value="Search" class="gsc-search-button" title="search"></td><td class="gsc-clear-button"><div class="gsc-clear-button" title="clear results">&nbsp;</div></td></tr></tbody></table><table cellspacing="0" cellpadding="0" class="gsc-branding"><tbody><tr style="display: none;"><td class="gsc-branding-user-defined"></td><td class="gsc-branding-text"><div class="gsc-branding-text">powered by</div></td><td class="gsc-branding-img"><img src="./Sorting and Searching_files/small-logo.png" class="gsc-branding-img"></td></tr></tbody></table></form></div></div>

</p><p><br>
</p></div>

<div id="content">
   <h1>4.2 &nbsp; Sorting and Searching</h1>
<p><br>

<font color="red">
This section under construction.       
</font>

</p><p><br>


</p><p>
The sorting problem is to rearrange a set of items in ascending order.
One reason that it is so useful is that it is much easier to search 
for something in a sorted list than an unsorted one.
In this section, we will consider in detail two classical algorithms for 
sorting and searching, along with several applications where their efficiency 
plays a critical role. 


</p><p>
<img src="./Sorting and Searching_files/20questions.png" align="right" hspace="25" alt="Twenty questions">
</p><p></p><h2>Binary search.</h2>
In the game of "twenty questions", your task 
is to guess the value of a hidden number that is one of the N integers
between 0 and N-1. 
(For simplicity, we will assume that N is a power of two.)
Each time that you make a guess, you are told whether
your guess is too high or too low.
An effective strategy is to maintain an interval that contains the hidden
number, guess the number in the middle of the interval, and
then use the answer to halve the interval size.
<a href="http://introcs.cs.princeton.edu/java/42sort/TwentyQuestions.java.html">TwentyQuestions.java</a>
implements this strategy, which is an example of the general
problem-solving method known as <em>binary search</em>.

<ul>
<li><em>Correctness proof.</em>
 First, we have to convince ourselves that the method is correct:
that it always leads us to the hidden number. We do so by establishing 
the following facts: 
<ul>
<li> The interval always contains the hidden number.
</li>
<li> The interval sizes are the powers of two, decreasing from N.
</li>
</ul>

<p>
The first of these facts is enforced by the code; the second follows by noting 
that if the interval size (hi-lo) is a power of two, then the next interval
size is (hi-lo)/2, which is the next smaller power of two.
These facts are the basis of an 
induction proof that the method operates as intended. Eventually, the interval 
size becomes 1, so we are guaranteed to find the number. 
</p></li>

<li><em>Running time analysis.</em>
Since the size of the interval decreases by a factor of 2 at each iteration
(and the base case is reached when N = 1), the running time of binary
search is lg N.

</li><li><em>Linear-logarithm chasm.</em>
The alternative to using binary search is to guess 0, then 1, then 2, then 3,
and so forth, until hitting the hidden number.
We refer to such an algorithm as a <em>brute-force</em> algorithm: it seems to get
the job done, but without much regard to the cost (which might prevent it from actually
getting the job done for large problems). In this case, the running time 
of the brute-force algorithm is sensitive to the input value, but could be as 
much as N and has expected value N/2 if the input value is chosen at random.
Meanwhile, binary search is guaranteed to use no more than lg N steps.

</li><li><em>Binary representation.</em>
If you look back to Program 1.3.7, you will
recognize that binary search is nearly the same computation as converting a
number to binary! Each guess determines one bit of the answer. In 
our example, the information that the number is between 0 and 127 says that 
the number of bits in its binary representation is 7, the answer to the first 
question (is the number less than 64?) tells us the value of the leading bit, the 
answer to the second question tells us the value of the next bit, and so forth. 
For example, if the number is 77, the sequence of answers no yes yes no 
no yes no immediately yields 1001101, the binary representation of 77. 
</li>


<p>
<img src="./Sorting and Searching_files/bisection.png" align="right" hspace="25" alt="Bisection search">
</p><li><em>Inverting a function.</em>
As an example of the utility of binary search in scientific computing,
we revisit a problem that we consider the problem of inverting an increasing
function. To fix ideas, we refer to the Gaussian distribution Φ when describing 
the method. Given a value y, our task is to find a value x such that
Φ(x) = y.
In this situation, we use real numbers as the endpoints of our 
interval, not integers, but we use the same essential method as for guessing a hidden 
integer: we halve the size of the interval at 
each step, keeping x in the interval, until the 
interval is sufficiently small that we know 
the value of x to within a desired precision δ.
We start with
an interval (lo, hi) known to contain x and use the following recursive strategy:

<ul>
<li> Compute m = lo + (hi - lo) / 2
</li><li> Base case: If (hi - lo) is less than δ, then returm m as an estimate of x
</li><li> Recursive step: otherwise, test whether Φ(m) &lt; y. If so look for x in
(lo, m); if not look for x in (m, hi)
</li></ul>

<p>

The key to this method is the idea that the function is increasing - for any
values a and b, knowing that Φ(a) &lt; &amp;Phi(b) tells us that a &lt; b, and vice versa.
In this context, binary search is often called <em>bisection search</em> because we 
bisect the interval at each stage. 

</p></li>



<li><em>Binary search in a sorted array.</em>
During much of the last century people would use a publication
known as a <em>phone book</em> to look up a person's phone number.
Entries appears in order, sorted by a key that identifies it (the person's name)
n both cases). 
A brute-force solution would be to start at the beginning, examine 
each entry one at a time, and continue until you find the name. No one uses 
that method: instead, you open the book to some interior page and look for 
the name on that page. If it is there, you are done; otherwise, you eliminate 
either the part of the book before the current page or the part of the book 
after the current page from consideration and repeat.

</li>


<li><em>Exception filter.</em>
We now use binary search to solve the <em>existence problem</em>: is a given
key in a sorted database of keys?
For example, when checking the spelling of a word, 
you need only know whether your word is in the dictionary 
and are not interested in the definition. In a computer search, 
we keep the information in an array, sorted in order of the key.
The binary search code in
<a href="http://introcs.cs.princeton.edu/java/42sort/BinarySearch.java.html">BinarySearch.java</a>
differs from our other applications in two details.
First, the file size N need not be a power of two. Second, it has to allow the 
possibility that the item sought is not in the array.
The client program implements an <em>exception filter</em>: it reads a sorted list
of strings from a file (which we refer to as the <em>whitelist</em>) and an arbitrary
sequence of strings from standard input and prints those in the sequence that
are <em>not</em> in the whitelist.
</li>

</ul>



<p></p><h2>Insertion sort.</h2>
Insertion sort is a brute-force sorting algorithm that is based on a 
simple method that people often use to arrange hands of playing cards.
Consider the cards one at a time and insert each into its proper place among those 
already considered (keeping them sorted). The following code mimics this 
process in a Java method that sorts strings in an array: 

<blockquote>
<table>
<tbody><tr><td><pre>public static void sort(String[] a) {
   int N = a.length;
   for (int i = 1; i &lt; N; i++)
      for (int j = i; j &gt; 0; j--)
         if (a[j-1].compareTo(a[j]) &gt; 0)
             exch(a, j, j-1);
         else break;
}
</pre></td></tr>
</tbody></table>
</blockquote>

The outer <tt>for</tt> loop sorts the first <tt>i</tt> entries in the array;
the inner <tt>for</tt> loop can complete the sort by putting <tt>a[i]</tt>
into its proper position in the array.


<p>
</p><blockquote>
<img src="./Sorting and Searching_files/insertionsort-trace.png" alt="Insertion sort trace">
</blockquote>
<p>

<br>

</p><ul>

<li><em>Mathematical analysis.</em>
The inner loop of the insertion sort code is within 
a double for loop, which suggests that the running time is quadratic, but we 
cannot immediately draw this conclusion because of the <tt>break</tt>.
<ul>

<li><em>Best case.</em> When the input array is already in sorted order,
the inner <tt>for</tt> loop amounts to nothing more than a comparison
(to learn that <tt>a[j-1]</tt> is less than <tt>a[j]</tt>) and the <tt>break</tt>,
so the total running time is linear.
</li>

<li><em>Worst case.</em> When the input is reverse sorted,
the inner loop fully completes without a <tt>break</tt>,
so the frequency of execution of the instructions in the inner loop is
1 + 2 + ... + N-1 ~ N^2 and the running time is quadratic.
</li>

<li><em>Average case.</em> When the input is <em>randomly</em> ordered
To understand the performance of insertion sort for randomly ordered,
we expect that each new element to be inserted is equally likely to fall 
into any position, so that element will move halfway 
to the left on average. Thus, we expect the running time to be 
1/2 + 2/2  + ... + (N-1)/2 ~ N^2 / 2.
</li></ul>
</li>

<li><em>Sorting other types of data.</em>
 We want to be able to sort all types of data, not just strings.
For sorting objects in an array, we need only assume that we can compare
two elements to see whether the first is bigger than, 
smaller than, or equal to the second. Java provides the <tt>Comparable</tt> interface 
for precisely this purpose. Simply put, a class that implements the 
<tt>Comparable</tt> interface promises to implement a method <tt>compareTo()</tt>
for objects of its type so that that <tt>a.compareTo(b)</tt>
returns a negative integer if <tt>a</tt> is less than <tt>b</tt>,
a positive integer if <tt>a</tt> is greater than <tt>b</tt>,
and 0 if <tt>a</tt> is equal to <tt>b</tt>. The 
precise meanings of <em>less than</em>, <em>greater than</em>,
and <em>equal</em> to are up to the data type, though implementations that do not
respect the natural laws of mathematics surrounding these concepts will yield
unpredictable results.  With this convention, 
<a href="http://introcs.cs.princeton.edu/java/42sort/Insertion.java.html">Insertion.java</a>
implements insertion sort so that it sorts arrays of
<tt>Comparable</tt> objects.
</li>

<li><em>Empirical analysis.</em>
Program <a href="http://introcs.cs.princeton.edu/java/42sort/InsertionTest.java.html">InsertionTest.java</a>
tests our hypothesis that insertion sort is quadratic for randomly ordered
files. It relies on the helper data type <a href="http://introcs.cs.princeton.edu/java/42sort/Stopwatch.java.html">Stopwatch.java</a>.

</li>

<li><em>Sensitivity to input.</em>
Note that <a href="http://introcs.cs.princeton.edu/java/42sort/InsertionTest.java.html">InsertionTest.java</a>
takes a command-line parameter M and runs M experiments for each array size, not just one.
One reason for doing so is that the running time of insertion 
sort is sensitive to its input values.
It is not correct to flatly predict that the running time of
insertion sort will be quadratic, because your application might involve input for 
which the running time is linear.
</li>

</ul>




<p></p><h2>Mergesort.</h2>
To develop a faster sorting method, we use a <em>divide-and-conquer</em> approach to
algorithm design that every programmer needs to understand. This nomenclature refers
to the idea that one way to solve a problem is to <em>divide</em> it into independent parts,
<em>conquer</em> them independently, and then use the solutions for the parts 
to develop a solution for the full problem. To sort an array with this strategy,
we divide it into two halves, sort the two halves independently, 
and then merge the results to sort the full array. 
This method is known as <em>mergesort</em>.
To sort a[lo, hi), we use the following recursive strategy: 
<ul>
<li><em>base case</em>: If the subarray size is 0 or 1, it is already sorted.
</li>
<li><em>recursive step</em>: Otherwise, compute m = lo + (hi - lo)/2, sort 
(recursively) the two subarrays a[lo, m) and a[m, hi), and merge 
them to produce a sorted result. 
</li>
</ul>

<p>
</p><blockquote>
<img src="./Sorting and Searching_files/mergesort.png" alt="Mergesort">
</blockquote>
<p>

<a href="http://introcs.cs.princeton.edu/java/42sort/Merge.java.html">Merge.java</a> is an implementation.
As usual, the easiest way to understand the merge process is to study a trace
of the contents of the array during the merge.


</p><p>
</p><blockquote>
<img src="./Sorting and Searching_files/merge-trace.png" alt="Trace of merging in mergesort">
</blockquote>
<p>


</p><ul>

<p>
</p><li><em>Mathematical analysis.</em>
The inner loop of mergesort is centered on the auxiliary array. The 
two <tt>for</tt> loops involve N iterations (and creating the array takes
time proportional to N), so the frequency of execution of the instructions in
the inner 
loop is proportional to the sum of the subarray sizes for all calls to the
recursive function.
The value of this quantity emerges when we arrange the calls 
on levels according to their size. 
On the first level, we have 1 call for size N, on the second level, 
we have 2 calls for size N/2, on the third level, we have 4 calls for size N/4, and 
so forth, down to the last level with N/2 calls of size 2.
There are precisely lg N levels, giving the grand total N lg N for the frequency of
execution of the instructions in the inner loop of mergesort.
This equation justifies a hypothesis that the running time of mergesort is
linearithmic.


<blockquote>
<img src="./Sorting and Searching_files/mergesort-analysis.png" alt="Mergesort analysis">
</blockquote>
<p>

</p></li><li><em>Quadratic-linearithmic chasm.</em>
The difference between N^2 and N lg N 
makes a huge difference in practical applications.
<em>Understanding the 
enormousness of this difference is another critical step to understanding
the importance of the design and analysis of algorithms.</em>
For a great many important 
computational problems, a speedup from quadratic to linearithmic
makes the difference between being able to solve 
a problem involving a huge amount of data and not being able to effectively 
address it at all. 
</li>

<li><em>Divide-and-conquer algorithms.</em>
The same basic approach is effective for 
many important problems, as you will learn if you take a course on algorithm 
design. 

</li><li><em>Reduction to sorting.</em>
 A problem <em>A</em> reduces to a problem <em>B</em> if we can use a 
solution to <em>B</em> to solve <em>A</em>.
Designing a new divide-and-conquer algorithm from 
scratch is sometimes akin to solving a puzzle that requires some experience 
and ingenuity, so you may not feel confident that you can do so at first. But 
it is often the case that a simpler approach is effective: given a new
problem that lends itself to a quadratic brute-force solution, ask yourself how you 
would solve it if the data were sorted in some way.
For example, consider the problem of determining whether the elements in an
array are all different. This problem reduces 
to sorting because we can sort the array, the make a linear pass through the 
sorted array to check whether any entry is equal to the next (if not, the
elements are all different.) 

</li>

</ul>


<p></p><h2>Frequency counts.</h2>
<a href="http://introcs.cs.princeton.edu/java/42sort/FrequencyCount.java.html">FrequencyCount.java</a> reads a sequence 
of strings from standard input and then prints a table of the distinct values 
found and the number of times each was found, in decreasing order of the 
frequencies. We accomplish this by two sorts.

<ul>
<li><em>Computing the frequencies.</em>
 Our first step is to sort the strings on standard 
input. In this case, we are not so much interested in the fact that the strings are 
put into sorted order, but in the fact that sorting brings equal strings together. 
If the input is 

<blockquote>
<table>
<tbody><tr><td><pre>to be or not to be to 
</pre></td></tr>
</tbody></table>
</blockquote>

then the result of the sort is 

<blockquote>
<table>
<tbody><tr><td><pre>be be not or to to to 
</pre></td></tr>
</tbody></table>
</blockquote>

with equal strings like the three occurrences of <tt>to</tt> brought 
together in the array. Now, with equal strings all together in the array,
we can make a single pass through the array to compute all the frequencies.
The <a href="http://introcs.cs.princeton.edu/java/42sort/Counter.java.html">Counter.java</a> data type that 
we considered in Section 3.x is the perfect tool for the job.

</li><li><em>Sorting the frequencies.</em>
 Next, we sort the <tt>Counter</tt> objects. We can do so in 
client code without any special arrangements because <tt>Counter</tt> implements 
the <tt>Comparable</tt> interface.

</li><li><em>Zipf's law.</em>
The application highlighted in <tt>FrequencyCount</tt>
is elementary linguistic analysis: which words appear most frequently in 
a text? A phenomenon known as
<a href="http://en.wikipedia.org/wiki/Zipf's_law">Zipf's law</a>
says that the frequency 
of the <em>i</em>th most frequent word in a text of <em>M</em>
distinct words is proportional to 1/<em>i</em>.
</li></ul>



<p></p><h2>Longest repeated substring.</h2>
 Another important computational task 
that reduces to sorting is the problem of finding the 
<em>longest repeated substring</em> in a given string.
This problem is simple to state and 
has many important applications, including computer-assisted music analysis,
cryptography, and data compression. Think briefly about how you might 
solve it. Could you find the longest repeated substring in a string that has 
millions of characters? 
Program <a href="http://introcs.cs.princeton.edu/java/42sort/LRS.java.html">LRS.java</a> is a clever solution
that uses <em>suffix sorting</em>.



<p></p><h2>Quicksort.</h2>
Quicksort is a divide-and-conquer method for sorting.  It works
by  <em>partitioning</em> an array of elements into two parts,
then sorting the parts
independently.  As we shall see, the precise position of the partition
depends on the initial order of the elements in the input file. 
The crux of the method is the partitioning process,
which rearranges the array to make the following three conditions hold:
<ul>

<li> The element <tt>a[i]</tt> is in its final place in the array for
<tt>i</tt>.

</li><li> None of the elements <tt>a[left]</tt>, ..., <tt>a[i-1]</tt>
is greater than <tt>a[i]</tt>.

</li><li> None of the elements in <tt>a[i+1]</tt>, ..., <tt>a[right]</tt>
is less than <tt>a[i]</tt>.

</li></ul>

<p>
We achieve a complete sort by partitioning, then recursively applying
the method to the subfiles.


</p><p>
We use the following general strategy to implement partitioning.
First, we arbitrarily choose <tt>a[right]</tt> to be the 
<em>partitioning element</em> - the one that will go into its final
position.  Next, we
scan from the left end of the array until we find an element greater
than the partitioning element, and we scan from the right end of the
array until we find an element less than the partitioning element.
The two elements that stopped the scans are obviously out of place in
the final partitioned array, so we exchange them.  Continuing in this
way, we ensure that no array elements to the left of the left index
are greater than the partitioning element, and no array elements to the
right of the right index are less than the partitioning element, as
depicted in the following diagram.


</p><p>
</p><center>
<img src="./Sorting and Searching_files/fig7-2.png" alt="Quicksort partitioning">
</center>
<p>

When the scan indices cross, all that we need to do to
complete the partitioning process is to exchange <tt>a[right]</tt>
with the leftmost element of the right subfile (the element pointed to by the
left index <tt>i</tt>).

</p><p><br>

Program <a href="http://introcs.cs.princeton.edu/java/42sort/QuickSort.java.html">QuickSort.java</a> implements
this algorithm.




</p><p>
</p><h4>Q + A</h4>

<p><b>Q.</b>
Why do we need to go to such lengths to prove a program correct? 
</p><p><b>A.</b>
To spare ourselves considerable pain. Binary search is a notable example. 
For example, you now understand binary search; a classic programming exercise
is to write a version that uses a while loop instead of recursion. Try solving
Exercise 4.2.2 without looking back at the code in the book. In a famous 
experiment, 
<a href="http://introcs.cs.princeton.edu/papers/bentley-binarysearch.pdf">J. Bentley</a>
once asked several professional programmers to do so, 
and most of their solutions were not correct.
According to Knuth, the first binary search algorithm was published in 1946,
but the first published binary search without bugs did not appear until 1962.


 
</p><p><b>Q.</b>
Are there implementations for sorting and searching in the Java libarary? 
</p><p><b>A.</b>
 Yes. The Java library <tt>java.util.Arrays</tt> contains the methods
<tt>Arrays.sort()</tt> and <tt>Arrays.binarySearch()</tt> that implement mergesort and binary 
search for <tt>Comparable</tt> types and a sorting implementation for primitive types 
based on a version of the <em>quicksort</em> algorithm, which is faster than mergesort 
and also sorts an array in place (without using any extra space). 
<a href="http://introcs.cs.princeton.edu/java/42sort/SystemSort.java.html">SystemSort.java</a> illustrates how to use
<tt>Arrays.sort()</tt>.



</p><p><b>Q.</b>
So why not just use them? 
</p><p><b>A.</b>
Feel free to do so. As with many topics we have studied, you will be able 
to use such tools more effectively if you understand the background behind 
them. 



</p><p>Q. Why doesn't the Java library use a randomized version of quicksort?
</p><p>A. Good question. At the very least, the library should cutoff to
some guaranteed N log N algorithm if it "realizes" it is in trouble.
Perhaps to avoid side effects.
Programmers may want their libraries to be deterministic
for debugging. But the library only uses quicksort for primitive types
when stability is not an issue, so the programmer probably wouldn't notice the
randomness, except in running time.


</p><p>
</p><h4>Exercises</h4>

<ol>

<li>
Develop an implementation of <a href="http://introcs.cs.princeton.edu/java/42sort/TwentyQuestions.java.html">TwentyQuestions.java</a>
that takes the maximum number <tt>N</tt> as command-line input. Prove that your
implementation is correct.

</li><li>
Add code to <tt>Insertion</tt> to produce the trace given in the text. 

</li><li>
Add code to <tt>Merge</tt> to produce the trace given in the text. 

</li><li>
Give traces of insertion sort and mergesort in the style of the traces in the text,
for the input 

<blockquote>
<table>
<tbody><tr><td><pre>it was the best of times it was
</pre></td></tr>
</tbody></table>
</blockquote>

</li><li>
Describe why it is desirable to use immutable keys with binary search.

</li><li>
Explain why we use <tt>lo + (hi - lo) / 2</tt> to compute the index midway
between <tt>lo</tt> and <tt>hi</tt> instead of using
<tt>(lo + hi) / 2</tt>. This can happen if the array contains
around a billion elements.
<p>
<em>Solution.</em>
The latter fails when <tt>lo + hi</tt> overflows an <tt>int</tt>.
<a href="http://googleresearch.blogspot.com/2006/06/extra-extra-read-all-about-it-nearly.html">
Joshua Bloch reports</a> that Sun's Java 1.5 implementation contained this bug.
Here is another correct version using bit-shifting.

</p><blockquote>
<table>
<tbody><tr><td><pre>int mid = lo + (hi - lo) / 2;
int mid = (lo + hi) &gt;&gt;&gt; 1;
</pre></td></tr>
</tbody></table>
</blockquote>

</li><li>
Modify <a href="http://introcs.cs.princeton.edu/java/42sort/BinarySearch.java.html">BinarySearch.java</a>
so that if the search key is in the array, it returns the
smallest index <tt>i</tt> for which <tt>a[i]</tt> is equal to key,
and otherwise, it returns <tt>-i</tt>, where <tt>i</tt>
is the smallest index such that <tt>a[i]</tt> is greater than key.

</li><li>
Describe what happens if you apply binary search to an unorderd array.
Why shouldn't you check whether the array is sorted before each call to binary search?
Could you check that the elements binary search examines are in ascending order?

</li><li>
Write a program <a href="http://introcs.cs.princeton.edu/java/42sort/Dedup.java.html">Dedup.java</a>
that reads strings from standard input and prints them on standard 
output with all duplicates removed (in sorted order).

</li><li>
Find the frequency distribution of words in your favorite book.
Does it obey Zipf's law?

</li><li>
Find the longest repeated substring in your favorite book.

</li><li>
Add code to <a href="http://introcs.cs.princeton.edu/java/42sort/LRS.java.html">LRS.java</a> to make it
print indices in the original string where the longest repeated substring
occurs.

</li><li>
Find a pathological input for which <a href="http://introcs.cs.princeton.edu/java/42sort/LRS.java.html">LRS.java</a>
runs in quadratic time (or worse).

</li><li>
Show that binary search in a sorted array is logarithmic as long as it 
eliminates at least a constant fraction of the array at each step. 

</li><li>
Modify <a href="http://introcs.cs.princeton.edu/java/42sort/BinarySearch.java.html">BinarySearch.java</a>
so that if the search key is not in the array, it returns the
largest index <tt>i</tt> for which <tt>a[i]</tt> is smaller than
<tt>key</tt> (or -1 if no such index exists).

</li><li>
Analyze mergesort mathematically when <em>N</em> is a power of 2,
as we did for binary search.

</li><li>
Analyze mergesort for the case when <em>N</em> is not a power of two.


</li></ol>



<p>
</p><h4>Creative Exercises</h4>

<p><em>
This list of exercises is intended to give you experience in developing fast solutions 
to typical problems. Think about using binary search, mergesort, or devising your 
own divide-and-conquer algorithm. Implement and test your algorithm.</em>

</p><ol start="18">

<li><b>Median.</b>
Add to <a href="http://introcs.cs.princeton.edu/java/42sort/StdStats.java.html">StdStats.java</a> a method
<tt>median()</tt> that computes in linearithmic time the median of a sequence
of <em>N</em> integers.
<p><em>Hint:</em> reduce to sorting.

</p></li><li><b>Mode.</b>
Add to <a href="http://introcs.cs.princeton.edu/java/42sort/StdStats.java.html">StdStats.java</a> a method
<tt>mode()</tt> that computes in linearithmic time the mode (value that
occurs most frequently) of a sequence of <em>N</em> integers.
<p><em>Hint:</em> reduce to sorting.

</p></li><li><b>Integer sort.</b>
Write a <em>linear</em>-time filter
<a href="http://introcs.cs.princeton.edu/java/42sort/IntegerSort.java.html">IntegerSort.java</a> that takes
from from standard input a sequence of integers that are between 0 and 99
and prints the same integers in sorted order on standard output.
For example, presented with the input sequence

<blockquote>
<table>
<tbody><tr><td><pre>98 2 3 1 0 0 0 3 98 98 2 2 2 0 0 0 2
</pre></td></tr>
</tbody></table>
</blockquote>

your program should print the output sequence

<blockquote>
<table>
<tbody><tr><td><pre>0 0 0 0 0 0 1 2 2 2 2 2 3 3 98 98 98
</pre></td></tr>
</tbody></table>
</blockquote>

</li><li><b>Floor and ceiling.</b>
Given a sorted array of <tt>Comparable</tt> items, write methods
<tt>floor()</tt> and <tt>ceil()</tt> that returns the index of the 
largest (or smallest) item not larger (or smaller) than an argument item
in logarithmic time.

</li><li><b>Closest pair.</b>
Given an array of <em>N</em> real numbers,
write a static method to find in linearithmic time the pair 
of integers that are closest in value.

</li><li><b>Farthest pair.</b>
Given an array of <em>N</em> real numbers,
write a static method to find in linear time the pair 
of integers that are farthest apart in value.


</li><li><b>Two sum.</b>
Write a static method that takes as argument an array of
<em>N</em> <tt>int</tt> values and determines in 
linearithmic time whether any <em>two</em> of them sum to 0.

</li><li><b>Three sum.</b>
Write a static method that takes as argument an array of
<em>N</em> <tt>int</tt> values and determines whether 
any <em>three</em> of them sum to 0. Your program should run in time
proportional to N^2 log N. 
<em>Extra credit</em>: develop a program that solves the problem in
quadratic time.

</li><li><b>Majority.</b> 
An element is a <em>majority</em> if it appears more than N/2 times. Write a 
static method that takes an array of <em>N</em> strings as argument and identifies a
majority (if it exists) in linear time.

</li><li><b>Common element.</b>
Write a static method that takes as argument three arrays of strings, 
determines whether there is any string common to all three arrays, and if so, 
returns one such string. The running time of your method should be
linearithmic in the total number of strings. 
<p><em>Hint</em>: sort each of the three lists, then describe how
to do a "3-way" merge.

</p></li><li><b>Prefix-free codes.</b>
In data compression, a set of strings is <em>prefix free</em> if
no string is a prefix of another. For example, the set of 
strings 01, 10, 0010, 1010 is not prefix free because 10 is a prefix of 1010.
Write a program that reads in a set of strings from standard input
and determines whether the set is prefix free.

</li><li><b>Longest common substring.</b>
Write a static method that finds the longest common substring of two given
strings <tt>s</tt> and <tt>t</tt>.

<p><em>Hint</em>: Suffix sort each string. Then merge the two
sorted suffixes together.


</p></li><li><b>Longest repeated, non-overlapping string.</b>
Modify <a href="http://introcs.cs.princeton.edu/java/42sort/LRS.java.html">LRS.java</a> to find the longest repeated substring 
that <em>does not overlap</em>. 

</li><li><b>Partitioning.</b>
Write a static method that sorts a <tt>Comparable</tt>
array that is known to have at most two different values.
<p><em>Hint:</em>
Maintain two pointers, one starting at the left end and moving 
right, the other starting at the right end and moving left.
Maintain the invariant that all elements to the left of the left
pointer are equal to the smaller of the two values and all
elements to the right of the right pointer are equal to the larger of the two values.


</p></li><li><b>Dutch national flag problem.</b>
Write a static method that sorts a <tt>Comparable</tt>
array that is known to have at most three different values.
(Edsger Dijkstra named this the <em>Dutch-national-flag problem</em> because the
result is three "stripes" of values like the three stripes in the flag.)

</li><li><b>Quicksort.</b>
Write a recursive program 
<a href="http://introcs.cs.princeton.edu/java/42sort/QuickSort.java.html">QuickSort.java</a> 
that sorts an array of randomly ordered distinct <tt>Comparable</tt> 
elements. 
<p><em>Hint:</em>
Use a method like the one described in the previous exercise. First, 
partition the array into a left part with all elements less than <em>v</em>,
followed by <em>v</em>, followed by a right part with all elements greater than <em>v</em>.
Then, recursively sort the two parts. 
</p><p><em>Extra credit:</em>
Modify your method (if necessary) to work properly when the elements are not 
necessarily distinct.

</p></li><li><b>Reverse domain.</b>
Write a program to read in a list of domain names from standard 
input, and print the reverse domain names in sorted order.
For example, the reverse domain of <tt>cs.princeton.edu</tt>
is <tt>edu.princeton.cs</tt>. This computation is 
useful for web log analysis.
To do so, create a data type <a href="http://introcs.cs.princeton.edu/java/42sort/Domain.java.html">Domain.java</a>
that implements the <tt>Comparable</tt> interface, using reverse domain name order.

</li><li><b>Local minimum in an array.</b>
Given an array of <em>N</em> real numbers, write a static method to find in logarithmic
time a <em>local minimum</em> (an index i such that a[i-1] &lt; a[i] &lt; a[i+1]).

<p><em>Solution.</em>
Query middle value a[n/2], and two neighbors a[n/2 - 1] and
a[n/2 + 1]. If a[n/2] is local minimum, stop; otherwise search in half
with smaller neighbor.

</p></li><li><b>Discrete distribution.</b>
Design a fast algorithm to repeatedly generate numbers from the discrete distribution: 
Given an array <tt>a[]</tt> of nonnegative real numbers that sum to 1,
the goal is to return index <tt>i</tt> with probability <tt>a[i]</tt>.
Form an array <tt>s[]</tt> of cumulated sums such that <tt>s[i]</tt> is the sum of the 
first <tt>i</tt> elements of <tt>a[]</tt>.
Now, generate a random real number <tt>r</tt> between 0 and 1, and use binary 
search to return the index <tt>i</tt> for which <tt>s[i]</tt> ≤ <tt>s[i+1]</tt>.


</li><li><b>Rhyming words.</b>
Write a program <a href="http://introcs.cs.princeton.edu/java/42sort/Rhymer.java.html">Rhymer.java</a> that
tabulates a list that you can use to find words that rhyme. Use the following approach:
<ul>
<li>Read in a dictionary of words into an array of strings. 
</li><li>Reverse the letters in each word (<tt>confound</tt> becomes <tt>dnuofnoc</tt>,
for example).
</li><li>Sort the resulting array.
</li><li>Reverse the letters in each word back to their original order.
</li></ul>

<p>
For example, <tt>confound</tt> is adjacent to words such as 
<tt>astound</tt> and <tt>surround</tt> in the resulting list.

</p></li></ol>




<p><br>
</p><h4>Web Exercises</h4>

<ol>

<li><b>Union of intervals.</b>
Given N intervals on the real line, determine the length of their union
in O(N log N) time. For example the union of the four intervals
[1, 3], [2, 4.5], [6, 9], and [7, 8] is 6.5.

</li><li><b>Coffee can problem.</b> (David Gries).
Suppose you have a coffee can which contains an unknown number of
black beans and an unknown number of white beans.
Repeat the following process until exactly one bean remains:
Select two beans from the can at random. If they are both the same
color, throw them both out, but insert another black bean.
If they are different colors, throw the black one away, but return the
white one.
Prove that this process terminates with exactly one bean left.
What can you deduce about the color of the last bean as a function 
of the initial number of black and white beans?
<em>Hint</em>: find a useful invariant maintained by the process.
<!-- Answer: if number of white beans is odd, then last bean is white;
otherwise black. Invariant: parity of number of white beans does not
change. -->

</li><li><b>Spam campaign.</b>
To initiate an illegal spam campaign, you have a list of email addresses
from various domains (the part of the email address that follows the
@ symbol). To better forge the return addresses, you
want to send the email from another user at the same domain. For
example, you might want to forge an email from nobody@princeton.edu
to somebody@princeton.edu. How would you process the email list to 
make this an efficient task?

</li><li><b>Order statistics.</b>
Given an array of N elements, not necessarily in ascending order,
devised an algorithm to find the kth largest one.
It should run in O(N) time on random inputs.

</li><li><b>Kendall's tau distance.</b>
Given two permutations, Kendall's tau distance is the number
of pairs out of position. "Bubblesort metric." Give an
O(N log N) algorithm to compute the Kendall tau distance 
between two permutations of size N.
Useful in top-k lists, social choice and voting theory,
comparing genes using expression profiles,  and
<a href="http://www10.org/cdrom/papers/577/">ranking search engine results</a>.

</li><li><b>Antipodal points.</b>
Given N points on a circle, centered at the origin, design an algorithm that determines
whether there are two points that are <em>antipodal</em>, i.e., the line connecting
the two points goes through the origin. Your algorithm should run in time proportional
to N log N.

</li><li><b>Antipodal points.</b>
Repeat the previous question, but assume the points are given in clockwise order.
Your algorithm should run in time proportional to N.

</li><li><b>Identity.</b>
Given an array <tt>a[]</tt> of <em>N</em> distinct integers
(positive or negative) in ascending order.
Devise an algorithm to find an index <tt>i</tt> such that
<tt>a[i] = i</tt> if such an index exists.
Hint: binary search.


</li><li><b>L1 norm.</b>
There are N circuit elements in the plane. You need to run a special
wire (parallel to the x-axis) across the circuit. Each circuit element
must be connected to the special wire. Where should you put the
special wire?
<em>Hint</em>: median minimizes L1 norm.

</li><li><b>Finding common elements.</b>
Given two arrays of N 64-bit integers, design an algorithm to print out
all elements that appear in both lists. The output should be in sorted order.
Your algorithm should run in N log N.
<em>Hint</em>: mergesort, mergesort, merge.
<em>Remark</em>: not possible to do better than N log N in comparison based model.

</li><li><b>Finding common elements.</b>
Repeat the above exercise but assume the first array has M integers and the
second has N integers where M is much less than N. Give an algorithm
that runs in N log M time.
<em>Hint</em>: sort and binary search.



</li><li><b>Anagrams.</b>
Design a O(N log N) algorithm to read in a list of words
and print out all anagrams. For example, the
strings "comedian" and "demoniac" are anagrams of each other.
Assume there are N words and each word contains at most 20 letters.
Designing a O(N^2) algorithms should not be too difficult, but
getting it down to O(N log N) requires some cleverness.

</li><li>
<b>Pattern recognition.</b>
Given a list of N points in the plane, find all subset of 3 or more
<a href="http://www.cs.princeton.edu/courses/archive/spring03/cs226/assignments/lines.html">
points that are collinear</a>.

</li><li>
<b>Pattern recognition.</b>
Given a list of N points in the plane in general position (no three are
collinear), find a new point p that is not collinear with any pair 
of the N original points.

<!-- O(N log N) should be possible -->

</li><li><b>Search in a sorted, rotated list.</b>
Given a sorted list of N integers that has been rotated an unknown
number of positions, e.g., 15 36 1 7 12 13 14, design an O(log N)
algorithm to determine if a given integer is in the list.

</li><li><b>Counting inversions.</b>
Each user ranks N songs in order of preference.
Given a preference list, find the user with the <em>closest</em> preferences.
Measure "closest" according to the number of inversions. Devise an N
log N algorithm for the problem.

</li><li><b>Throwing cats from an N-story building.</b>
Suppose that you have an N story building and a bunch of cats.
Suppose also that a cat dies if it is thrown off floor F or higher,
and lives otherwise.
Devise a strategy to determine the floor F, while killing O(log N)
cats.

</li><li><b>Throwing cats from a building.</b>
Repeat the previous exercise, but devise a strategy that kills
O(log F) cats.
<em>Hint</em>: repeated doubling and binary search.

</li><li><b>Throwing two cats from an N-story building.</b>
Repeat the previous question, but now assume you only have two cats.
Now your goal is to minimize the number of throws.
Devise a strategy to determine F that involves throwing cats
O(√N) times (before killing them both).
This application might occur in practice if search hits (cat surviving
fall) are much cheaper than misses (cat dying).


</li><li><b>Throwing two cats from a building.</b>
Repeat the previous question, but only throw O(√F) cats.
<em>Reference</em>: ???.

</li><li><b>Nearly sorted.</b>
Given an array of N elements, each which is at most
k positions from its target position, devise an algorithm that
sorts in O(N log k) time.

<p><em>Solution 1:</em> divide the file into N/k pieces of size k, and
sort each piece in O(k log k) time, say using mergesort.
Note that this preserves the property that no element is more
than k elements out of position.
Now, merge each blocks of k elements with the block to its left.

</p><p><em>Solution 2:</em> insert the first k elements into a binary
heap. Insert the next element from the array into the heap,
and delete the minimum element from the heap. Repeat.

</p></li><li><b>Merging k sorted lists.</b>
Suppose you have k sorted lists with a total of N elements.
Give an O(N log k) algorithm to produce a sorted list of all N
elements.


</li><li><b>Longest common reverse complemented substring.</b>
Given two DNA strings, find the longest substring that appears in one, and whose
reverse Watson-Crick complement appears in the other. Two strings s and
t are reverse complements if t is the reverse of s except with the
following substitutions A&lt;-&gt;T, C&lt;-&gt;G. For example ATTTCGG and CCGAAAT
are reverse complements of each other.
<em>Hint</em>: suffix sort.

</li><li><b>Circular string linearization.</b>
Plasmids contain DNA in a circular molecule instead of a linear one.
To facilitate search in a database of DNA strings, we need a place to
break it up to form a linear string. A natural choice is the
place that leaves the lexicographically smallest string.
Devise an algorithm to compute this canonical representation of
the circular string
<em>Hint</em>: suffix sort.


</li><li><b>Find all matches.</b>
Given a text string, find <em>all</em> matches of the query string.
<em>Hint</em>: combine suffix sorting and binary search.

</li><li><b>Longest repeated substring with less memory.</b>
Instead of using an array of substrings where suffixes[i] refers to
the ith sorted suffix, maintain an array of integers so that
index[i] refers to the offset of the ith sorted suffix. To compare
the substrings represented by a = index[i] and b = index[j], compare
the character <tt>s.charAt(a)</tt> against <tt>s.charAt(b)</tt>,
<tt>s.charAt(a+1)</tt> against <tt>s.charAt(b+1)</tt>, and so forth.
How much memory do you save? Is your program faster?

</li><li><b>Idle time.</b>
Suppose that a parallel machine processes n jobs. Job j is 
processed from s<sub>j</sub> to t<sub>j</sub>.
Given the list of start and finish times, find the largest
interval where the machine is idle.
Find the largest interval where the machine is non-idle.


</li><li><b>Local minimum of a matrix.</b>
Given an N-by-N array <tt>a</tt> of N<sup>2</sup> distinct integers,
design an O(N) algorithm to find a <em>local minimum</em>:
an pair of indices i and j such that a[i][j] &lt; a[i+1][j],
a[i][j] &lt; a[i][j+1], a[i][j] &lt; a[i-1][j], and a[i][j] &lt; a[i][j-1].

<!-- find minimum in row N/2, check neighbors p and q in column,
if p or q is smaller then recur in that half -->

</li><li><b>Monotone 2d array.</b>
Give an n-by-n array of elements such that each row is in 
ascending order and each column is in ascending order,
devise an O(n) algorithm to determine if a given element x
in the array. You may assume all elements in the n-by-n array
are distinct.
<!-- can't do better than n since the off diagonal can contain
elements in arbitrary order, so algorithm must examine all
of them -->

</li><li><b>2D maxima.</b>
Given a set of n points in the plane, point (xi, yi) dominates (xj, yj)
if xi &gt; xj and yi &gt; yj. A maxima is a point that is not dominated by
any other point in the set. Devise an O(n log n) algorithm to find
all maxima.
Application: on x-axis is space efficiency, on y-axis is time efficiency.
Maxima are useful algorithms.
Hint: sort in ascending order according to x-coordinate; scan from right
to left, recording the highest y-value seen so far, and mark these as
maxima.

</li><li><b>Compound words.</b>
Read in a list of words from standard input, and print out all
two-word <em>compound</em> words. If <tt>after</tt>, <tt>thought</tt>,
and <tt>afterthought</tt> are in the list, then <tt>afterthought</tt>
is  a compound word. Note: the components in the compound word
need not have the same length.

</li><li><b>Smith's rule.</b>
The following problem arises in supply chain management.
You have a bunch of jobs to schedule on a single machine.
(Give example.)
Job j requires p[j] units of processing time.
Job j has a positive weight w[j] which represents its relative
importance - think of it as the inventory cost of storing
the raw materials for job j for 1 unit of time.
If job j finishes being processed at time t, then it costs
t * w[j] dollars.
The goal is to sequence the jobs so as to
minimize the sum of the weighted completion times of each job.
Write a program <tt>SmithsRule.java</tt>
that reads in a command line parameter N and a list of N jobs 
specified by their processing time p[j] and their weight w[j],
and output an optimal sequence in which to process their jobs.
<em>Hint:</em> Use <em>Smith's rule</em>: schedule
the jobs in order of their ratio of processing time to weight.
This greedy rule turns out to be optimal.

</li><li><b>Sum of four primes.</b>
The Goldbach conjecture says that all positive even integers 
greater than 2 can be expressed as the sum of two primes.
 Given an input parameter N (odd or even),
express N as the sum of four primes (not necessarily distinct)
or report that it is impossible to do so. To make your algorithm
fast for large N, do the following steps:
<ol>
<li>Compute all primes less than N using the Sieve of Eratosthenes.
</li><li>Tabulate a list of sums of two primes.
</li><li>Sort the list.
</li><li>Check if there are two numbers in the list that sum to N. If so,
print out the corresponding four primes.
</li></ol>


</li><li><b>Typing monkeys and power laws.</b>
(Micahel Mitzenmacher)
Suppose that a 
<a href="http://www.internetmathematics.org/volumes/1/2/pp226_251.pdf">typing monkey</a>
creates random words by
appending each of 26 possible lettter with probability p to the
current word, and finishes the word with probability
1 - 26p. Write a program to estimate the frequency spectrum of
the words produced.

</li><li><b>Typing monkeys and power laws.</b>
Repeat the previous exercise, but assume that the letters a-z occur
proportional to the following probabilities, which are typical of
English text.



<p><br>
</p><center>
<table cellspacing="1" cellpadding="5" border="0">
<tbody><tr>
<th>CHAR</th>
<th>FREQ</th>
<th>&nbsp;</th>
<th>CHAR</th>
<th>FREQ</th>
<th>&nbsp;</th>
<th>CHAR</th>
<th>FREQ</th>
<th>&nbsp;</th>
<th>CHAR</th>
<th>FREQ</th>
<th>&nbsp;</th>
<th>CHAR</th>
<th>FREQ</th>
</tr>

<tr align="center" bgcolor="#ebebeb">
<td>A</td>
<td>8.04</td>
<td></td>
<td>G</td>
<td>1.96</td>
<td></td>
<td>L</td>
<td>4.14</td>
<td></td>
<td>Q</td>
<td>0.11</td>
<td></td>
<td>V</td>
<td>0.99</td>
</tr>

<tr align="center" bgcolor="#ebebeb">
<td>B</td>
<td>1.54</td>
<td></td>
<td>H</td>
<td>5.49</td>
<td></td>
<td>M</td>
<td>2.53</td>
<td></td>
<td>R</td>
<td>6.12</td>
<td></td>
<td>W</td>
<td>1.92</td>
</tr>


<tr align="center" bgcolor="#ebebeb">
<td>C</td>
<td>3.06</td>
<td></td>
<td>I</td>
<td>7.26</td>
<td></td>
<td>N</td>
<td>7.09</td>
<td></td>
<td>S</td>
<td>6.54</td>
<td></td>
<td>X</td>
<td>0.19</td>
</tr>


<tr align="center" bgcolor="#ebebeb">
<td>D</td>
<td>3.99</td>
<td></td>
<td>J</td>
<td>0.16</td>
<td></td>
<td>O</td>
<td>7.60</td>
<td></td>
<td>T</td>
<td>9.25</td>
<td></td>
<td>Y</td>
<td>1.73</td>
</tr>


<tr align="center" bgcolor="#ebebeb">
<td>E</td>
<td>12.51</td>
<td></td>
<td>K</td>
<td>0.67</td>
<td></td>
<td>P</td>
<td>2.00</td>
<td></td>
<td>U</td>
<td>2.71</td>
<td></td>
<td>Z</td>
<td>0.09</td>
</tr>

<tr align="center" bgcolor="#ebebeb">
<td>F</td>
<td>2.30</td>
<td></td>
</tr>

</tbody></table>
</center>

<p><br>



</p></li><li><b>Binary search.</b>
Justify why the following modified version of <tt>binarySearch()</tt>
works. Prove that if the key is in the array, it correctly
returns the smallest index <tt>i</tt> such that a[i] = key;
if the key is not in the array, it returns -i where 
i is the smallest index such that a[i] &gt; key.

<!-- http://www.dcs.qmw.ac.uk/~pt/algorithms/binary.html -->


<blockquote>
<table>
<tbody><tr><td><pre>// precondition array a in ascending order
public static int binarySearch(long[] a, long key) {
   int bot = -1;
   int top = a.length;
   while (top - bot &gt; 1) {
      int mid = bot + (top - bot) / 2;
      if (key &gt; a[mid]) bot = mid;
      else              top = mid;
   }
   if (a[top] == key) return  top;
   else               return -top - 1;
} 
</pre></td></tr>
</tbody></table>
</blockquote>

<em>Answer.</em> The while loop invariant says top &gt;= bot + 2. This
implies bot &lt; mid &lt; top. Hence length of interval strictly
decreases in each iteration.
While loop also maintains the invariant: <tt>a[bot] &lt; key &lt;= a[top]</tt>,
with the contention that <tt>a[-1]</tt> is -infinity and <tt>a[N]</tt>
is +infinity.




</li><li><b>Range search.</b>
Given a database of all tolls collected in NJ road system in 2006,
devise a scheme to answer queries of the form:
extract sum of all tolls collected in a given time interval.
Use a <tt>Toll</tt> data type that implements
the <tt>Comparable</tt> interface, where the key is
the time that the toll was collected.

<p>
<em>Hint:</em> sort by time, compute a cumulative sum
of the first i tolls, then use binary search to find 
the desired interval.


</p></li><li><b>Longest repeated substrings.</b>
Modify <a href="http://introcs.cs.princeton.edu/java/42sort/LRS.java.html">LRS.java</a> to find <em>all</em>
longest repeated substrings.



</li><li><b>Non-recursive binary search.</b>
Write a non-recurisve version of binary search.

<blockquote>
<table>
<tbody><tr><td><pre>public static int binarySearch(long[] a, long key) {
   int bot = 0;
   int top = a.length - 1;
   while (bot &lt;= top) {
      int mid = bot + (top - bot) / 2;
      if      (key &lt; a[mid]) top = mid - 1;
      else if (key &gt; a[mid]) bot = mid + 1;
      else return mid;
   }
   return -1;
} 
</pre></td></tr>
</tbody></table>
</blockquote>



</li><li><b>Two sum to x.</b>
Given a sorted list of N integers and a target integer x,
determine in O(N) time whether there
are any two that sum to exactly x.
<p><em>Hint</em>: maintain an index lo = 0 and hi = N-1
and compute a[lo] + a[hi]. If the sum equals x, you are done;
if the sum is less than x, decrement hi; if the sum is greater
than x, increment lo. Be careful if one (or more) of the
integers are 0.

</p></li><li><b>Zero of a monotonic function.</b>
Let f be a monotonically increasing function with f(0) &lt; 0
and f(N) &gt; 0. Find the smallest integer i such that f(i) &gt; 0.
Devise an algorithm that makes O(log N) calls to f().
<p>
<em>Hint</em>: assuming we know N, maintaing an interval [lo, hi]
such that f[lo] &lt; 0 and f[hi] &gt; 0 and apply binary search.
If we don't know N, repeatedly compute f(1), f(2), f(4), f(8),
f(16), and so on until you find a value of N such that 
f(N) &gt; 0.

</p></li><li><b>Bitonic max.</b>
Let <tt>a[]</tt> be an array that starts out increasing, reaches
a maximum, and then decreases.
Design an O(log N) algorithm to find the index
of the maximum value.

</li><li><b>Bitonic search.</b>
An array is <em>bitonic</em> if it is comprised of an increasing
sequence of integers followed immediately by a decreasing sequence of integers.
Given a bitonic array <tt>a</tt> of N distinct integers, describe
how to determine whether a given integer is in the array in O(log N)
steps.
Hint: find the maximum, then binary search in each piece.


</li><li><b>Median in two sorted arrays.</b>
Given two sorted arrays of size N<sub>1</sub> and N<sub>2</sub>,
find the median of all elements in O(log N) time
where N = N<sub>1</sub> + N<sub>2</sub>.
<em>Hint</em>: design a more general
algorithm that finds the kth largest element for any k.
Compute the median element in the large of the two lists
and; throw away at least 1/4 of the elements and recur.

</li><li><b>Element distinctness.</b>
Give an array of N long integers, devise an O(N log N) algorithm
to determine if any two are equal.
<em>Hint</em>: sorting brings equal values together.


</li><li><b>Duplicate count.</b>
Give a sorted array of N elements, possibly with duplicates,
find the index of the first and last occurrence of k in
O(log N) time.
Give a sorted array of N elements, possibly with duplicates,
find the number of occurrences of element k in O(log N) time.
<em>Hint</em>: modify binary search.




</li></ol>






<p><b>Scientific example of sorting.</b>
Google display search results in descending order of "importance",
a spreadsheet displays columns sorted by a particular field,
Matlab sorts the real eigenvalues of a symmetric matrix in
descending order.
Sorting also arises as a critical subroutine in many applications 
that appear to have nothing to do with sorting at all including:
data compression (see the Burrows-Wheeler programming assignment),
computer graphics (convex hull, closest pair),
computational biology (longest common substring discussed
below), supply chain management (schedule jobs to minimize
weighted sum of completion times), combinatorial optimization (Kruskal's
algorithm), social choice and voting (Kendall's tau distance),
Historically, sorting was most important for commercial applications,
but sorting also plays a major role in the scientific computing
infrastructure.
<a href="http://www.nas.nasa.gov/Research/Reports/Techreports/1990/rnr-90-017-abstract.html">NASA</a>
and the fluids mechanics community use sorting to
study problems in rarefied flow; these collision detection
problems are especially
challenging since they involve ten of billions of particles and
can only be solved on supercomputers in parallel.
Similar sorting techniques are used in some fast N-body simulation codes.
Another important scientific application of sorting is for load balancing
the processors of a parallel supercomputers.
Scientists rely on clever sorting algorithm to perform load-balancing
on such systems.



<br><br>
</p><p class="footer">
<em>Last modified on June 07, 2012.</em><br><br>
Copyright © 2002–2012
<a href="http://www.cs.princeton.edu/~rs" class="footer">Robert Sedgewick</a>
and
<a href="http://www.cs.princeton.edu/~wayne" class="footer">Kevin Wayne</a>.
All rights reserved.
</p></div>




<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script><script src="./Sorting and Searching_files/ga.js" type="text/javascript"></script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-10811519-1");
pageTracker._trackPageview();
} catch(err) {}</script>











 
<table cellspacing="0" cellpadding="0" class="gstl_50 gssb_c" style="width: 159px; display: none; top: 914px; position: absolute; left: 23px;"><tbody><tr><td class="gssb_f"></td><td class="gssb_e" style="width: 100%;"></td></tr></tbody></table></body></html>